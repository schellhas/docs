Lecture 1 - Architecture
========================

Architecture - Part 1
---------------------

.. epigraph::

	The difference between a good and a poor arthictect is that the poor architect succumbs to every temptation and the good one resists it.

	-- Ludwig Wittgenstein

Coarse structure
~~~~~~~~~~~~~~~~

A system (operating systems, software systems) consists of:

- Elemente
- Relations between elements

The elements are functional units with interactions of different kinds in between (data flow, request flow, synchronization, call, communication, ...)

Coarse division of an OS
~~~~~~~~~~~~~~~~~~~~~~~~

The elements and concepts are processes that interact with each other in order to complete a task. An operating system thus consists of multiple processes interacting with each other. They are not hardware, but must be started otherwise. What comes first? How can we start these processes? The kernel does that, it starts first. It initialized the other processes.

These two are the main areas. The **process** area and the **kernel** (or infrastructure) area. These are the two fundamental areas of an OS.

They interact with each other through the *kernel interface*.

The process area
~~~~~~~~~~~~~~~~

Can be further dissected. Applications want some type of abstraction of hardware and the kernel interface. We provide this abstraction, so the virtual machine to the applications. *Supporting basic* **services** provides this virtual machine (slides). Users want to start applications, which the **control** *of operation* does (slides). It also accesses the kernel because the kernel manages these processes.

Services
~~~~~~~~

Finer resolution: Services

Main task: Give abstraction to applications, so it doesn't have to address the hardware/resource specifically. So the applications can *easily* use the interface to the services, and the services have a *tideous* interface to the hardware.

Distinction:

**Logical resource:** "thought up" for organizational reasons realized by real resources. Examples: file, window, ...

**Real (physical) resource:** real existence, to be touched. Examples: disc, keyboard, ...

.. list-table:: Distinction
	:header-rows: 1

	* - Logical resource
	  - Real (physical) resource
	* - "thought up" for organizational reasons realized by real resources. Examples: file, window, ...
	  - real existence, to be touched. Examples: disc, keyboard, ...

How to deal with resources
~~~~~~~~~~~~~~~~~~~~~~~~~~

Applications want to use them, we have to prepare them. We have to decide which applications are allowed to access the resource, especially when they are limited. When the application is done with the resource, the resource must be free'd to be used by the next.

Dealing with resources
~~~~~~~~~~~~~~~~~~~~~~

The term "operation" is used, when the resource is accessed (for example writing). The application can do that *easily* through the virtual machine.

"Management" is done when multiple accesses have to be coordinated or when letting an application access, and denying access to another application.

Operating system services
~~~~~~~~~~~~~~~~~~~~~~~~~

Now we already have 4 layers.

- Management of logical resources
- Operation of logical resources
- Management of real resources
- Operation of real resources
- (Real resources)

Control
~~~~~~~

We want the user to be able to control the system. This is done either with a **control itnerface** (manual) or a **procedural interface** (scripts, procedures, ...).

Overview
~~~~~~~~

Now we have the full resource management as well as the control for the applications. Users use applications, applications use resources.

- Control interface
- Procedual interface
- Application
- Management of logical resources
- Operation of logical resources
- Management of real resources
- Operation of real resources
- ------------------------------
- Real resources/Kernel, whichever granularity you chose..

Remarks
~~~~~~~

The resources and functions can be organised and distinguished. Thus, these layers can also access higher layers to for example access another device. *Upward calls are allowed*.

The Kernel
~~~~~~~~~~

Now we know what the process area looks like. Now we will zoom into the kernel area.

We need an area that *processes* the calls made to the kernel. The **kernel operations**. What types of calls could that be? For example the creation of new processes. Then we would need to manage processes. The **process state change operations** layer would be called to perform this change. The **data structure operations** area holds data structures which manages and saves process states. The **kernel memory management** manages the kernel memory which holds the data structures for the processes. This should be a dynamic system so processes can be created and removed dynamically. If we don't have a dynamic system, for example when we know which applications we want to use (maybe a microwave), we can also use a static system, or don't need a kernel memory management module at all.

Types of realization of the kernel
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Where do we put the kernel?

- Scattered across programs
	- Historically, we know that they can also be in applications, today still in embedded systems, where the kernel operation can be in the process area of the process.
- Resident, compact, sealed
	- Many OSes nowadays seperate the kernel address space, which holds all procedures and functions of the kernel. This way, the processes call the kernel via the kernel interface.

Microkernel architecture
~~~~~~~~~~~~~~~~~~~~~~~~

Which functions, apart from the most important, should be in the kernel address space?

The first, MULTIX, UNIX, ... saw the task in putting all OS functionality into the kernel address space. This way, the applications can just use the kernel interface. With time, the kernel grew a lot. At some point, people said this isn't functional anymore, the kernel is way too big, and we don't know if parts of the kernel function properly. They then tried to keep the kernel as small as possible. These are the **microkernels**.

Per design, very little function inside the kernel. The other OS services are implemented just like applications. The memory footprint shrunk.

These are sometimes then even called *nanokernel* or *picokernel*. There is no general agreement *what* a kernel is, usually the creator names it one of the terms. The general philosophical designs are **macro- or microkernels**.

Process management and process communication are *essential*.

Monolithical Systems
~~~~~~~~~~~~~~~~~~~~

All applications and kernel processes are seen as one single program that runs on the hardware. Often in embedded systems. Nowadays also embedded systems are often seperated though.

Monolithical OS-Kernel
~~~~~~~~~~~~~~~~~~~~~~

Macro - as many as posssible. Could also be called monolithical OS-kernel. All OS functionalities are put into the, sometimes unstructured, kernel. The whole kernel must thus be viewed as *trusted*.

Microkernel OS
~~~~~~~~~~~~~~

The services of the OS are outside of the kernel, the applications access them via IPC. IPC and Process management are the only functionalities that stay in the kernel.

Advantages of a microkernel architecture
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Why should this be reduction be better?

First, the structure of the OS was better. It forced the developers to structure things properly. It also made the functionalities that stay in the kernel smaller, and thus easier to maintain and check for quality. Security and stability can be addressed better. It also means the realiability is higher, because when an OS process fails, you can restart this OS process, in a macrokernel you would need to reboot your system. Microkernels are also more secure. The sel4 kernel is goated. Limitation of function also means limit of code that can access hardware. One of the first marketing-viable functions, is that the microkernel can handle different OS-implementations on top that can run different applications.

Drawback of microkernel architecute
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Usually worse performance. Why? Interaction of OS-functionalities that are processes have to use IPC which is an overhead. Each time they have to perform a system call, which is expensive.

	*Architecture - Part 1 done*

Architecture - Part 2
---------------------

General Design Principles
~~~~~~~~~~~~~~~~~~~~~~~~~

KISS (keep it small and simple; keep it simple, stupid)

- Plurality only when necessary, rather keep it basic and simple
- It is much harder to make a software that is so simple, there are no obvious deficiencies, the other is to make is so compelex there are no obvious deficiencies.
- Everything should be as simple as possible, but not simpler.

.. epigraph::

	Perfection in design is achieved not when theres nothing more to add, but rather when there is nothing more to take away

	-- Antoine de Saint-Exup√©rty, 1900-1944

Modularization
~~~~~~~~~~~~~~

Is the main tool in os-dev. Each module has a function that is designed, so that the interaction in the module is very high, and the interaction to other modules is very low. The modules should have a simple interface. The modules should, in terms of their functionality, reasonably small and reasonably complex.

Hierarchization
~~~~~~~~~~~~~~~

Should be in a tree-like hierarchy so the system stays scalable and managed complexity well.

























